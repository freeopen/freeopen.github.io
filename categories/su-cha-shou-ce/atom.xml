<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Freeopen - 速查手册</title>
    <subtitle>7 labo.</subtitle>
    <link rel="self" type="application/atom+xml" href="/categories/su-cha-shou-ce/atom.xml"/>
    <link rel="alternate" type="text/html" href="/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-07-20T00:00:00+00:00</updated>
    <id>/categories/su-cha-shou-ce/atom.xml</id>
    <entry xml:lang="en">
        <title>集群配置备忘</title>
        <published>2023-06-12T09:57:19+00:00</published>
        <updated>2023-07-20T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="/blog/mycloud/"/>
        <id>/blog/mycloud/</id>
        
        <summary type="html">&lt;p&gt;linux 服务器在部署生产环境时，各种中间件的集群配置精华记录。包括 redis、nacos、minio、rabbitMq、kafka 等。
友情提醒，任何用 java 或 类java 语言实现的中间件，尽量不要部署成集群，因为太占内存了，有替代品优先使用替代品。&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Mac OS 自用手册</title>
        <published>2023-06-01T16:46:20+00:00</published>
        <updated>2023-06-01T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="/blog/macos/"/>
        <id>/blog/macos/</id>
        
        <summary type="html">&lt;p&gt;整理一些苹果电脑的实用小技巧, 包括曾经踩过的坑。&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>linux 服务器自用手册</title>
        <published>2023-05-31T16:31:49+00:00</published>
        <updated>2023-07-13T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="/blog/linux/"/>
        <id>/blog/linux/</id>
        
        <summary type="html">&lt;p&gt;以 centos 系统为主，兼容大部分 linux 系统的管理手册。&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>机器学习术语表</title>
        <published>2018-02-26T00:00:00+00:00</published>
        <updated>2018-02-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="/blog/glossary/"/>
        <id>/blog/glossary/</id>
        
        <summary type="html">&lt;p&gt;为方便读论文时查询术语，只做英文目录，我会不时把新遇到的术语增补到这里。
&lt;a href=&quot;https:&#x2F;&#x2F;developers.google.com&#x2F;machine-learning&#x2F;glossary&#x2F;&quot;&gt;初版&lt;&#x2F;a&gt;来自 Google Developers 网站。&lt;&#x2F;p&gt;
&lt;p&gt;本术语表定义了一般机器学习术语以及特定于 TensorFlow 的术语。&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Python Numpy 教程</title>
        <published>2017-12-11T00:00:00+00:00</published>
        <updated>2017-12-11T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="/blog/python/"/>
        <id>/blog/python/</id>
        
        <content type="html" xml:base="/blog/python/">&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;cs231n.github.io&#x2F;python-numpy-tutorial&#x2F;&quot;&gt;原文&lt;&#x2F;a&gt; | &lt;a href=&quot;https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;20878530?refer=intelligentunit&quot;&gt;原译文&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;freeopen: 原译文没有目录导航，阅读起来不方便。补全少量漏翻的地方。虽然内容很基础，但需要时快速查阅一下还是很不错的。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;p&gt;Python是一门伟大的通用编程语言，在一些常用库（numpy, scipy, matplotlib）的帮助下，它又会变成一个强大的科学计算环境。&lt;&#x2F;p&gt;
&lt;p&gt;我们期望你们中大多数人对于Python语言和Numpy库比较熟悉，而对于没有Python经验的同学，这篇教程可以帮助你们快速了解Python编程环境和如何使用Python作为科学计算工具。&lt;&#x2F;p&gt;
&lt;p&gt;一部分同学对于Matlab有一定经验。对于这部分同学，我们推荐阅读 &lt;a href=&quot;https:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;numpy-dev&#x2F;user&#x2F;numpy-for-matlab-users.html&quot;&gt;numpy for Matlab users 页面&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;本教程内容涵盖:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Basic Python: Basic data types (Containers, Lists, Dictionaries, Sets, Tuples), Functions, Classes&lt;&#x2F;li&gt;
&lt;li&gt;Numpy: Arrays, Array indexing, Datatypes, Array math, Broadcasting&lt;&#x2F;li&gt;
&lt;li&gt;SciPy: Image operations, MATLAB files, Distance between points,&lt;&#x2F;li&gt;
&lt;li&gt;Matplotlib: Plotting, Subplots, Images&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;basics-of-python&quot;&gt;Basics of Python&lt;&#x2F;h2&gt;
&lt;p&gt;Python是一种高级的，动态类型的多范型编程语言。很多时候，大家会说Python看起来简直和伪代码一样，这是因为你能够通过很少行数的代码表达出很有力的思想。举个例子，下面是用Python实现的经典的quicksort算法例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def quicksort(arr):
    if len(arr) &amp;lt;= 1:
        return arr
    pivot = arr[len(arr) &amp;#x2F;&amp;#x2F; 2]
    left = [x for x in arr if x &amp;lt; pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x &amp;gt; pivot]
    return quicksort(left) + middle + quicksort(right)

print quicksort([3,6,8,10,1,2,1])
# Prints &amp;quot;[1, 1, 2, 3, 6, 8, 10]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;python-versions&quot;&gt;Python versions&lt;&#x2F;h3&gt;
&lt;p&gt;Python有两个支持的版本，分别是2.7和3.4。这有点让人迷惑，3.0向语言中引入了很多不向后兼容的变化，2.7下的代码有时候在3.4下是行不通的。在这个课程中，我们使用的是2.7版本。&lt;&#x2F;p&gt;
&lt;p&gt;如何查看版本呢？使用&lt;code&gt;python --version&lt;&#x2F;code&gt;命令。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;basic-data-types&quot;&gt;Basic data types&lt;&#x2F;h3&gt;
&lt;p&gt;和大多数编程语言一样，Python拥有一系列的基本数据类型，比如整型、浮点型、布尔型和字符串等。这些类型的使用方式和在其他语言中的使用方式是类似的。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Numbers&lt;&#x2F;strong&gt;: 整型和浮点型的使用与其他语言类似。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;x = 3
print(type(x)) # Prints &amp;quot;&amp;lt;class &amp;#x27;int&amp;#x27;&amp;gt;&amp;quot;
print(x)       # Prints &amp;quot;3&amp;quot;
print(x + 1)   # Addition; prints &amp;quot;4&amp;quot;
print(x - 1)   # Subtraction; prints &amp;quot;2&amp;quot;
print(x * 2)   # Multiplication; prints &amp;quot;6&amp;quot;
print(x ** 2)  # Exponentiation; prints &amp;quot;9&amp;quot;
x += 1
print(x)  # Prints &amp;quot;4&amp;quot;
x *= 2
print(x)  # Prints &amp;quot;8&amp;quot;
y = 2.5
print(type(y)) # Prints &amp;quot;&amp;lt;class &amp;#x27;float&amp;#x27;&amp;gt;&amp;quot;
print(y, y + 1, y * 2, y ** 2) # Prints &amp;quot;2.5 3.5 5.0 6.25&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;需要注意的是，Python中没有 &lt;code&gt;x++&lt;&#x2F;code&gt; 和 &lt;code&gt;x--&lt;&#x2F;code&gt; 的操作符。&lt;&#x2F;p&gt;
&lt;p&gt;Python也有内置的长整型和复杂数字类型，具体细节可以查看&lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;2&#x2F;library&#x2F;stdtypes.html#numeric-types-int-float-long-complex&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Booleans&lt;&#x2F;strong&gt;: Python实现了所有的布尔逻辑，但用的是英语，而不是我们习惯的操作符（比如&lt;code&gt;&amp;amp;&amp;amp;&lt;&#x2F;code&gt;和&lt;code&gt;||&lt;&#x2F;code&gt;等）。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;t = True
f = False
print(type(t)) # Prints &amp;quot;&amp;lt;class &amp;#x27;bool&amp;#x27;&amp;gt;&amp;quot;
print(t and f) # Logical AND; prints &amp;quot;False&amp;quot;
print(t or f)  # Logical OR; prints &amp;quot;True&amp;quot;
print(not t)   # Logical NOT; prints &amp;quot;False&amp;quot;
print(t != f)  # Logical XOR; prints &amp;quot;True&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Strings&lt;&#x2F;strong&gt;: Python对字符串的支持非常棒。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;hello = &amp;#x27;hello&amp;#x27;    # String literals can use single quotes
world = &amp;quot;world&amp;quot;    # or double quotes; it does not matter.
print(hello)       # Prints &amp;quot;hello&amp;quot;
print(len(hello))  # String length; prints &amp;quot;5&amp;quot;
hw = hello + &amp;#x27; &amp;#x27; + world  # String concatenation
print(hw)  # prints &amp;quot;hello world&amp;quot;
hw12 = &amp;#x27;%s %s %d&amp;#x27; % (hello, world, 12)  # sprintf style string formatting
print(hw12)  # prints &amp;quot;hello world 12&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;字符串对象有一系列有用的方法，比如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;s = &amp;quot;hello&amp;quot;
print(s.capitalize())  # Capitalize a string; prints &amp;quot;Hello&amp;quot;
print(s.upper())       # Convert a string to uppercase; prints &amp;quot;HELLO&amp;quot;
print(s.rjust(7))      # Right-justify a string, padding with spaces; prints &amp;quot;  hello&amp;quot;
print(s.center(7))     # Center a string, padding with spaces; prints &amp;quot; hello &amp;quot;
print(s.replace(&amp;#x27;l&amp;#x27;, &amp;#x27;(ell)&amp;#x27;))  # Replace all instances of one substring with another;
                                # prints &amp;quot;he(ell)(ell)o&amp;quot;
print(&amp;#x27;  world &amp;#x27;.strip())  # Strip leading and trailing whitespace; prints &amp;quot;world&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果想详细查看字符串方法，请看&lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;2&#x2F;library&#x2F;stdtypes.html#string-methods&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;containers&quot;&gt;Containers&lt;&#x2F;h3&gt;
&lt;p&gt;Python有以下几种容器类型：列表（lists）、字典（dictionaries）、集合（sets）和元组（tuples）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;lists&quot;&gt;Lists&lt;&#x2F;h4&gt;
&lt;p&gt;列表就是Python中的数组，但是列表长度可变，且能包含不同类型元素。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;xs = [3, 1, 2]    # Create a list
print(xs, xs[2])  # Prints &amp;quot;[3, 1, 2] 2&amp;quot;
print(xs[-1])     # Negative indices count from the end of the list; prints &amp;quot;2&amp;quot;
xs[2] = &amp;#x27;foo&amp;#x27;     # Lists can contain elements of different types
print(xs)         # Prints &amp;quot;[3, 1, &amp;#x27;foo&amp;#x27;]&amp;quot;
xs.append(&amp;#x27;bar&amp;#x27;)  # Add a new element to the end of the list
print(xs)         # Prints &amp;quot;[3, 1, &amp;#x27;foo&amp;#x27;, &amp;#x27;bar&amp;#x27;]&amp;quot;
x = xs.pop()      # Remove and return the last element of the list
print(x, xs)      # Prints &amp;quot;bar [3, 1, &amp;#x27;foo&amp;#x27;]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;列表的细节，同样可以查阅&lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;2&#x2F;tutorial&#x2F;datastructures.html#more-on-lists&quot;&gt;文档&lt;&#x2F;a&gt;.。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Slicing&lt;&#x2F;strong&gt;: 为了一次性地获取列表中的元素，Python提供了一种简洁的语法，这就是切片。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;nums = list(range(5))     # range is a built-in function that creates a list of integers
print(nums)               # Prints &amp;quot;[0, 1, 2, 3, 4]&amp;quot;
print(nums[2:4])          # Get a slice from index 2 to 4 (exclusive); prints &amp;quot;[2, 3]&amp;quot;
print(nums[2:])           # Get a slice from index 2 to the end; prints &amp;quot;[2, 3, 4]&amp;quot;
print(nums[:2])           # Get a slice from the start to index 2 (exclusive); prints &amp;quot;[0, 1]&amp;quot;
print(nums[:])            # Get a slice of the whole list; prints &amp;quot;[0, 1, 2, 3, 4]&amp;quot;
print(nums[:-1])          # Slice indices can be negative; prints &amp;quot;[0, 1, 2, 3]&amp;quot;
nums[2:4] = [8, 9]        # Assign a new sublist to a slice
print(nums)               # Prints &amp;quot;[0, 1, 8, 9, 4]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Loops&lt;&#x2F;strong&gt;: 我们可以这样遍历列表中的每一个元素：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;animals = [&amp;#x27;cat&amp;#x27;, &amp;#x27;dog&amp;#x27;, &amp;#x27;monkey&amp;#x27;]
for animal in animals:
    print(animal)
# Prints &amp;quot;cat&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;monkey&amp;quot;, each on its own line.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果想要在循环体内访问每个元素的指针，可以使用内置的&lt;code&gt;enumerate&lt;&#x2F;code&gt;函数&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;animals = [&amp;#x27;cat&amp;#x27;, &amp;#x27;dog&amp;#x27;, &amp;#x27;monkey&amp;#x27;]
for idx, animal in enumerate(animals):
    print(&amp;#x27;#%d: %s&amp;#x27; % (idx + 1, animal))
# Prints &amp;quot;#1: cat&amp;quot;, &amp;quot;#2: dog&amp;quot;, &amp;quot;#3: monkey&amp;quot;, each on its own line
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;List comprehensions&lt;&#x2F;strong&gt;: 在编程的时候，我们常常想要将一种数据类型转换为另一种。下面是一个简单例子，将列表中的每个元素变成它的平方。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;nums = [0, 1, 2, 3, 4]
squares = []
for x in nums:
    squares.append(x ** 2)
print(squares)   # Prints [0, 1, 4, 9, 16]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;使用列表推导，你就可以让代码简化很多：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;nums = [0, 1, 2, 3, 4]
squares = [x ** 2 for x in nums]
print(squares)   # Prints [0, 1, 4, 9, 16]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;列表推导还可以包含条件：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;nums = [0, 1, 2, 3, 4]
even_squares = [x ** 2 for x in nums if x % 2 == 0]
print(even_squares)  # Prints &amp;quot;[0, 4, 16]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;dictionaries&quot;&gt;Dictionaries&lt;&#x2F;h4&gt;
&lt;p&gt;字典用来储存（键, 值）对，这和Java中的&lt;code&gt;Map&lt;&#x2F;code&gt;差不多。你可以这样使用它：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;d = {&amp;#x27;cat&amp;#x27;: &amp;#x27;cute&amp;#x27;, &amp;#x27;dog&amp;#x27;: &amp;#x27;furry&amp;#x27;}  # Create a new dictionary with some data
print(d[&amp;#x27;cat&amp;#x27;])       # Get an entry from a dictionary; prints &amp;quot;cute&amp;quot;
print(&amp;#x27;cat&amp;#x27; in d)     # Check if a dictionary has a given key; prints &amp;quot;True&amp;quot;
d[&amp;#x27;fish&amp;#x27;] = &amp;#x27;wet&amp;#x27;     # Set an entry in a dictionary
print(d[&amp;#x27;fish&amp;#x27;])      # Prints &amp;quot;wet&amp;quot;
# print(d[&amp;#x27;monkey&amp;#x27;])  # KeyError: &amp;#x27;monkey&amp;#x27; not a key of d
print(d.get(&amp;#x27;monkey&amp;#x27;, &amp;#x27;N&amp;#x2F;A&amp;#x27;))  # Get an element with a default; prints &amp;quot;N&amp;#x2F;A&amp;quot;
print(d.get(&amp;#x27;fish&amp;#x27;, &amp;#x27;N&amp;#x2F;A&amp;#x27;))    # Get an element with a default; prints &amp;quot;wet&amp;quot;
del d[&amp;#x27;fish&amp;#x27;]         # Remove an element from a dictionary
print(d.get(&amp;#x27;fish&amp;#x27;, &amp;#x27;N&amp;#x2F;A&amp;#x27;)) # &amp;quot;fish&amp;quot; is no longer a key; prints &amp;quot;N&amp;#x2F;A&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;想要知道字典的其他特性，请查阅&lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;2&#x2F;library&#x2F;stdtypes.html#dict&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Loops&lt;&#x2F;strong&gt;：在字典中，用键来迭代更加容易。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;d = {&amp;#x27;person&amp;#x27;: 2, &amp;#x27;cat&amp;#x27;: 4, &amp;#x27;spider&amp;#x27;: 8}
for animal in d:
    legs = d[animal]
    print(&amp;#x27;A %s has %d legs&amp;#x27; % (animal, legs))
# Prints &amp;quot;A person has 2 legs&amp;quot;, &amp;quot;A cat has 4 legs&amp;quot;, &amp;quot;A spider has 8 legs&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果你想要访问键和对应的值，那就使用&lt;code&gt;iteritems&lt;&#x2F;code&gt;方法：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;d = {&amp;#x27;person&amp;#x27;: 2, &amp;#x27;cat&amp;#x27;: 4, &amp;#x27;spider&amp;#x27;: 8}
for animal, legs in d.items():
    print(&amp;#x27;A %s has %d legs&amp;#x27; % (animal, legs))
# Prints &amp;quot;A person has 2 legs&amp;quot;, &amp;quot;A cat has 4 legs&amp;quot;, &amp;quot;A spider has 8 legs&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Dictionary comprehensions&lt;&#x2F;strong&gt;：和列表推导类似，但是允许你方便地构建字典。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;nums = [0, 1, 2, 3, 4]
even_num_to_square = {x: x ** 2 for x in nums if x % 2 == 0}
print(even_num_to_square)  # Prints &amp;quot;{0: 0, 2: 4, 4: 16}&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;sets&quot;&gt;Sets&lt;&#x2F;h4&gt;
&lt;p&gt;集合是独立不同个体的无序集合。示例如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;animals = {&amp;#x27;cat&amp;#x27;, &amp;#x27;dog&amp;#x27;}
print(&amp;#x27;cat&amp;#x27; in animals)   # Check if an element is in a set; prints &amp;quot;True&amp;quot;
print(&amp;#x27;fish&amp;#x27; in animals)  # prints &amp;quot;False&amp;quot;
animals.add(&amp;#x27;fish&amp;#x27;)       # Add an element to a set
print(&amp;#x27;fish&amp;#x27; in animals)  # Prints &amp;quot;True&amp;quot;
print(len(animals))       # Number of elements in a set; prints &amp;quot;3&amp;quot;
animals.add(&amp;#x27;cat&amp;#x27;)        # Adding an element that is already in the set does nothing
print(len(animals))       # Prints &amp;quot;3&amp;quot;
animals.remove(&amp;#x27;cat&amp;#x27;)     # Remove an element from a set
print(len(animals))       # Prints &amp;quot;2&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;和前面一样，要知道更详细的，查看&lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3.5&#x2F;library&#x2F;stdtypes.html#set&quot;&gt;文档&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Loops&lt;&#x2F;strong&gt;：在集合中循环的语法和在列表中一样，但是集合是无序的，所以你在访问集合的元素的时候，不能做关于顺序的假设。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;animals = {&amp;#x27;cat&amp;#x27;, &amp;#x27;dog&amp;#x27;, &amp;#x27;fish&amp;#x27;}
for idx, animal in enumerate(animals):
    print(&amp;#x27;#%d: %s&amp;#x27; % (idx + 1, animal))
# Prints &amp;quot;#1: fish&amp;quot;, &amp;quot;#2: dog&amp;quot;, &amp;quot;#3: cat&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Set comprehensions&lt;&#x2F;strong&gt;：和字典推导一样，可以很方便地构建集合：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from math import sqrt
nums = {int(sqrt(x)) for x in range(30)}
print(nums)  # Prints &amp;quot;{0, 1, 2, 3, 4, 5}&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;tuples&quot;&gt;Tuples&lt;&#x2F;h4&gt;
&lt;p&gt;元组是一个值的有序列表（不可改变）。从很多方面来说，元组和列表都很相似。和列表最重要的不同在于，元组可以在字典中用作键，还可以作为集合的元素，而列表不行。例子如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;d = {(x, x + 1): x for x in range(10)}  # Create a dictionary with tuple keys
t = (5, 6)        # Create a tuple
print(type(t))    # Prints &amp;quot;&amp;lt;class &amp;#x27;tuple&amp;#x27;&amp;gt;&amp;quot;
print(d[t])       # Prints &amp;quot;5&amp;quot;
print(d[(1, 2)])  # Prints &amp;quot;1&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3.5&#x2F;tutorial&#x2F;datastructures.html#tuples-and-sequences&quot;&gt;文档&lt;&#x2F;a&gt;有更多元组的信息。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;functions&quot;&gt;Functions&lt;&#x2F;h3&gt;
&lt;p&gt;Python函数使用&lt;code&gt;def&lt;&#x2F;code&gt;来定义函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def sign(x):
    if x &amp;gt; 0:
        return &amp;#x27;positive&amp;#x27;
    elif x &amp;lt; 0:
        return &amp;#x27;negative&amp;#x27;
    else:
        return &amp;#x27;zero&amp;#x27;

for x in [-1, 0, 1]:
    print(sign(x))
# Prints &amp;quot;negative&amp;quot;, &amp;quot;zero&amp;quot;, &amp;quot;positive&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们常常使用可选参数来定义函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;def hello(name, loud=False):
    if loud:
        print(&amp;#x27;HELLO, %s!&amp;#x27; % name.upper())
    else:
        print(&amp;#x27;Hello, %s&amp;#x27; % name)

hello(&amp;#x27;Bob&amp;#x27;) # Prints &amp;quot;Hello, Bob&amp;quot;
hello(&amp;#x27;Fred&amp;#x27;, loud=True)  # Prints &amp;quot;HELLO, FRED!&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;classes&quot;&gt;Classes&lt;&#x2F;h3&gt;
&lt;p&gt;Python对于类的定义是简单直接的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;class Greeter(object):

    # Constructor
    def __init__(self, name):
        self.name = name  # Create an instance variable

    # Instance method
    def greet(self, loud=False):
        if loud:
            print(&amp;#x27;HELLO, %s!&amp;#x27; % self.name.upper())
        else:
            print(&amp;#x27;Hello, %s&amp;#x27; % self.name)

g = Greeter(&amp;#x27;Fred&amp;#x27;)  # Construct an instance of the Greeter class
g.greet()            # Call an instance method; prints &amp;quot;Hello, Fred&amp;quot;
g.greet(loud=True)   # Call an instance method; prints &amp;quot;HELLO, FRED!&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;更多类的信息请查阅&lt;a href=&quot;https:&#x2F;&#x2F;docs.python.org&#x2F;3.5&#x2F;tutorial&#x2F;classes.html&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;numpy&quot;&gt;Numpy&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.numpy.org&#x2F;&quot;&gt;Numpy&lt;&#x2F;a&gt;是Python中用于科学计算的核心库。它提供了高性能的多维数组对象，以及相关工具。如何熟悉MATLAB, 你可以从这份&lt;a href=&quot;http:&#x2F;&#x2F;wiki.scipy.org&#x2F;NumPy_for_Matlab_Users&quot;&gt;教程&lt;&#x2F;a&gt;开始学习Numpy.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;arrays&quot;&gt;Arrays&lt;&#x2F;h3&gt;
&lt;p&gt;一个numpy数组是一个由不同数值组成的网格。网格中的数据都是同一种数据类型，可以通过非负整型数的元组来访问。维度的数量被称为数组的阶，数组的大小是一个由整型数构成的元组，可以描述数组不同维度上的大小。&lt;&#x2F;p&gt;
&lt;p&gt;我们可以从列表创建数组，然后利用方括号访问其中的元素：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

a = np.array([1, 2, 3])   # Create a rank 1 array
print(type(a))            # Prints &amp;quot;&amp;lt;class &amp;#x27;numpy.ndarray&amp;#x27;&amp;gt;&amp;quot;
print(a.shape)            # Prints &amp;quot;(3,)&amp;quot;
print(a[0], a[1], a[2])   # Prints &amp;quot;1 2 3&amp;quot;
a[0] = 5                  # Change an element of the array
print(a)                  # Prints &amp;quot;[5, 2, 3]&amp;quot;

b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 array
print(b.shape)                     # Prints &amp;quot;(2, 3)&amp;quot;
print(b[0, 0], b[0, 1], b[1, 0])   # Prints &amp;quot;1 2 4&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Numpy还提供了很多其他创建数组的方法：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

a = np.zeros((2,2))   # Create an array of all zeros
print(a)              # Prints &amp;quot;[[ 0.  0.]
                      #          [ 0.  0.]]&amp;quot;

b = np.ones((1,2))    # Create an array of all ones
print(b)              # Prints &amp;quot;[[ 1.  1.]]&amp;quot;

c = np.full((2,2), 7)  # Create a constant array
print(c)               # Prints &amp;quot;[[ 7.  7.]
                       #          [ 7.  7.]]&amp;quot;

d = np.eye(2)         # Create a 2x2 identity matrix
print(d)              # Prints &amp;quot;[[ 1.  0.]
                      #          [ 0.  1.]]&amp;quot;

e = np.random.random((2,2))  # Create an array filled with random values
print(e)                     # Might print &amp;quot;[[ 0.91940167  0.08143941]
                             #               [ 0.68744134  0.87236687]]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其他数组相关方法，请查看&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;numpy&#x2F;user&#x2F;basics.creation.html#arrays-creation&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;array-indexing&quot;&gt;Array indexing&lt;&#x2F;h3&gt;
&lt;p&gt;Numpy提供了多种访问数组的方法。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Slicing&lt;&#x2F;strong&gt;：和Python列表类似，numpy数组可以使用切片语法。因为数组可以是多维的，所以你必须为每个维度指定好切片。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Use slicing to pull out the subarray consisting of the first 2 rows
# and columns 1 and 2; b is the following array of shape (2, 2):
# [[2 3]
#  [6 7]]
b = a[:2, 1:3]

# A slice of an array is a view into the same data, so modifying it
# will modify the original array.
print(a[0, 1])   # Prints &amp;quot;2&amp;quot;
b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]
print(a[0, 1])   # Prints &amp;quot;77&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;你可以同时使用整型和切片语法来访问数组。但是，这样做会产生一个比原数组低阶的新数组。需要注意的是，这里和MATLAB中的情况是不同的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Two ways of accessing the data in the middle row of the array.
# Mixing integer indexing with slices yields an array of lower rank,
# while using only slices yields an array of the same rank as the
# original array:
row_r1 = a[1, :]    # Rank 1 view of the second row of a
row_r2 = a[1:2, :]  # Rank 2 view of the second row of a
print(row_r1, row_r1.shape)  # Prints &amp;quot;[5 6 7 8] (4,)&amp;quot;
print(row_r2, row_r2.shape)  # Prints &amp;quot;[[5 6 7 8]] (1, 4)&amp;quot;

# We can make the same distinction when accessing columns of an array:
col_r1 = a[:, 1]
col_r2 = a[:, 1:2]
print(col_r1, col_r1.shape)  # Prints &amp;quot;[ 2  6 10] (3,)&amp;quot;
print(col_r2, col_r2.shape)  # Prints &amp;quot;[[ 2]
                             #          [ 6]
                             #          [10]] (3, 1)&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Integer array indexing&lt;&#x2F;strong&gt;：当我们使用切片语法访问数组时，得到的总是原数组的一个子集。整型数组访问允许我们利用其它数组的数据构建一个新的数组：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

a = np.array([[1,2], [3, 4], [5, 6]])

# An example of integer array indexing.
# The returned array will have shape (3,) and
print(a[[0, 1, 2], [0, 1, 0]])  # Prints &amp;quot;[1 4 5]&amp;quot;

# The above example of integer array indexing is equivalent to this:
print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints &amp;quot;[1 4 5]&amp;quot;

# When using integer array indexing, you can reuse the same
# element from the source array:
print(a[[0, 0], [1, 1]])  # Prints &amp;quot;[2 2]&amp;quot;

# Equivalent to the previous integer array indexing example
print(np.array([a[0, 1], a[0, 1]]))  # Prints &amp;quot;[2 2]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;整型数组访问语法还有个有用的技巧，可以用来选择或者更改矩阵中每行中的一个元素：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

# Create a new array from which we will select elements
a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])

print(a)  # prints &amp;quot;array([[ 1,  2,  3],
          #                [ 4,  5,  6],
          #                [ 7,  8,  9],
          #                [10, 11, 12]])&amp;quot;

# Create an array of indices
b = np.array([0, 2, 0, 1])

# Select one element from each row of a using the indices in b
print(a[np.arange(4), b])  # Prints &amp;quot;[ 1  6  7 11]&amp;quot;

# Mutate one element from each row of a using the indices in b
a[np.arange(4), b] += 10

print(a)  # prints &amp;quot;array([[11,  2,  3],
          #                [ 4,  5, 16],
          #                [17,  8,  9],
          #                [10, 21, 12]])
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Boolean array indexing&lt;&#x2F;strong&gt;：布尔型数组访问可以让你选择数组中任意元素。通常，这种访问方式用于选取数组中满足某些条件的元素，举例如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

a = np.array([[1,2], [3, 4], [5, 6]])

bool_idx = (a &amp;gt; 2)   # Find the elements of a that are bigger than 2;
                     # this returns a numpy array of Booleans of the same
                     # shape as a, where each slot of bool_idx tells
                     # whether that element of a is &amp;gt; 2.

print(bool_idx)      # Prints &amp;quot;[[False False]
                     #          [ True  True]
                     #          [ True  True]]&amp;quot;

# We use boolean array indexing to construct a rank 1 array
# consisting of the elements of a corresponding to the True values
# of bool_idx
print(a[bool_idx])  # Prints &amp;quot;[3 4 5 6]&amp;quot;

# We can do all of the above in a single concise statement:
print(a[a &amp;gt; 2])     # Prints &amp;quot;[3 4 5 6]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;为了教程的简短，有很多数组访问的细节我们没有详细说明，可以查看&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;numpy&#x2F;reference&#x2F;arrays.indexing.html&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;datatypes&quot;&gt;Datatypes&lt;&#x2F;h3&gt;
&lt;p&gt;每个Numpy数组都是数据类型相同的元素组成的网格。Numpy提供了很多的数据类型用于创建数组。当你创建数组的时候，Numpy会尝试猜测数组的数据类型，你也可以通过参数直接指定数据类型，例子如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

x = np.array([1, 2])   # Let numpy choose the datatype
print(x.dtype)         # Prints &amp;quot;int64&amp;quot;

x = np.array([1.0, 2.0])   # Let numpy choose the datatype
print(x.dtype)             # Prints &amp;quot;float64&amp;quot;

x = np.array([1, 2], dtype=np.int64)   # Force a particular datatype
print(x.dtype)                         # Prints &amp;quot;int64&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;更多细节查看&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;numpy&#x2F;reference&#x2F;arrays.dtypes.html&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;array-math&quot;&gt;Array math&lt;&#x2F;h3&gt;
&lt;p&gt;基本数学计算函数会对数组中元素逐个进行计算，既可以利用操作符重载，也可以使用函数方式：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

x = np.array([[1,2],[3,4]], dtype=np.float64)
y = np.array([[5,6],[7,8]], dtype=np.float64)

# Elementwise sum; both produce the array
# [[ 6.0  8.0]
#  [10.0 12.0]]
print(x + y)
print(np.add(x, y))

# Elementwise difference; both produce the array
# [[-4.0 -4.0]
#  [-4.0 -4.0]]
print(x - y)
print(np.subtract(x, y))

# Elementwise product; both produce the array
# [[ 5.0 12.0]
#  [21.0 32.0]]
print(x * y)
print(np.multiply(x, y))

# Elementwise division; both produce the array
# [[ 0.2         0.33333333]
#  [ 0.42857143  0.5       ]]
print(x &amp;#x2F; y)
print(np.divide(x, y))

# Elementwise square root; produces the array
# [[ 1.          1.41421356]
#  [ 1.73205081  2.        ]]
print(np.sqrt(x))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;和MATLAB不同，&lt;code&gt;*&lt;&#x2F;code&gt;是元素逐个相乘，而不是矩阵乘法。在Numpy中使用&lt;code&gt;dot&lt;&#x2F;code&gt;来进行矩阵乘法：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])

v = np.array([9,10])
w = np.array([11, 12])

# Inner product of vectors; both produce 219
print(v.dot(w))
print(np.dot(v, w))

# Matrix &amp;#x2F; vector product; both produce the rank 1 array [29 67]
print(x.dot(v))
print(np.dot(x, v))

# Matrix &amp;#x2F; matrix product; both produce the rank 2 array
# [[19 22]
#  [43 50]]
print(x.dot(y))
print(np.dot(x, y))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Numpy提供了很多计算数组的函数，其中最常用的一个是&#x27;sum&#x27;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

x = np.array([[1,2],[3,4]])

print(np.sum(x))  # Compute sum of all elements; prints &amp;quot;10&amp;quot;
print(np.sum(x, axis=0))  # Compute sum of each column; prints &amp;quot;[4 6]&amp;quot;
print(np.sum(x, axis=1))  # Compute sum of each row; prints &amp;quot;[3 7]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;想要了解更多函数，可以查看&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;numpy&#x2F;reference&#x2F;routines.math.html&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;除了计算，我们还常常改变数组或者操作其中的元素。其中将矩阵转置是常用的一个，在Numpy中，使用&lt;code&gt;T&lt;&#x2F;code&gt;来转置矩阵：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

x = np.array([[1,2], [3,4]])
print(x)    # Prints &amp;quot;[[1 2]
            #          [3 4]]&amp;quot;
print(x.T)  # Prints &amp;quot;[[1 3]
            #          [2 4]]&amp;quot;

# Note that taking the transpose of a rank 1 array does nothing:
v = np.array([1,2,3])
print(v)    # Prints &amp;quot;[1 2 3]&amp;quot;
print(v.T)  # Prints &amp;quot;[1 2 3]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Numpy还提供了更多操作数组的方法，请查看&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;numpy&#x2F;reference&#x2F;routines.array-manipulation.html&quot;&gt;文档&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;broadcasting&quot;&gt;Broadcasting&lt;&#x2F;h3&gt;
&lt;p&gt;广播是一种强有力的机制，它让Numpy可以让不同大小的矩阵在一起进行数学计算。我们常常会有一个小的矩阵和一个大的矩阵，然后我们会需要用小的矩阵对大的矩阵做一些计算。&lt;&#x2F;p&gt;
&lt;p&gt;举个例子，如果我们想要把一个向量加到矩阵的每一行，我们可以这样做：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

# We will add the vector v to each row of the matrix x,
# storing the result in the matrix y
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = np.empty_like(x)   # Create an empty matrix with the same shape as x

# Add the vector v to each row of the matrix x with an explicit loop
for i in range(4):
    y[i, :] = x[i, :] + v

# Now y is the following
# [[ 2  2  4]
#  [ 5  5  7]
#  [ 8  8 10]
#  [11 11 13]]
print(y)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样是行得通的，但是当&#x27;x&#x27;矩阵非常大，利用循环来计算就会变得很慢很慢。我们可以换一种思路：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

# We will add the vector v to each row of the matrix x,
# storing the result in the matrix y
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
vv = np.tile(v, (4, 1))   # Stack 4 copies of v on top of each other
print(vv)                 # Prints &amp;quot;[[1 0 1]
                          #          [1 0 1]
                          #          [1 0 1]
                          #          [1 0 1]]&amp;quot;
y = x + vv  # Add x and vv elementwise
print(y)  # Prints &amp;quot;[[ 2  2  4
          #          [ 5  5  7]
          #          [ 8  8 10]
          #          [11 11 13]]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Numpy广播机制可以让我们不用创建&lt;code&gt;vv&lt;&#x2F;code&gt;，就能直接运算，看看下面例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

# We will add the vector v to each row of the matrix x,
# storing the result in the matrix y
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = x + v  # Add v to each row of x using broadcasting
print(y)  # Prints &amp;quot;[[ 2  2  4]
          #          [ 5  5  7]
          #          [ 8  8 10]
          #          [11 11 13]]&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;y = x + v&lt;&#x2F;code&gt;这一行，即使&lt;code&gt;x&lt;&#x2F;code&gt;的维度为&lt;code&gt;(4, 3)&lt;&#x2F;code&gt;, &lt;code&gt;v&lt;&#x2F;code&gt;的维度为&lt;code&gt;(3,)&lt;&#x2F;code&gt;，但由于广播机制，&lt;code&gt;v&lt;&#x2F;code&gt;在计算时的实际维度为&lt;code&gt;(4, 3)&lt;&#x2F;code&gt;，其中每行是&lt;code&gt;v&lt;&#x2F;code&gt;的副本，然后再每个元素相加求得结果。&lt;&#x2F;p&gt;
&lt;p&gt;对两个数组使用广播机制要遵守下列规则：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;如果数组的秩不同，使用1来将秩较小的数组进行扩展，直到两个数组的尺寸的长度都一样。&lt;&#x2F;li&gt;
&lt;li&gt;如果两个数组在某个维度上的长度是一样的，或者其中一个数组在该维度上长度为1，那么我们就说这两个数组在该维度上是相容的。&lt;&#x2F;li&gt;
&lt;li&gt;如果两个数组在所有维度上都是相容的，他们就能使用广播。&lt;&#x2F;li&gt;
&lt;li&gt;如果两个输入数组的尺寸不同，那么注意其中较大的那个尺寸。因为广播之后，两个数组的尺寸将和那个较大的尺寸一样。&lt;&#x2F;li&gt;
&lt;li&gt;在任何一个维度上，如果一个数组的长度为1，另一个数组长度大于1，那么在该维度上，就好像是对第一个数组进行了复制。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;如果上述解释看不明白，可以读一读&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;numpy&#x2F;user&#x2F;basics.broadcasting.html&quot;&gt;文档&lt;&#x2F;a&gt;和这个&lt;a href=&quot;http:&#x2F;&#x2F;wiki.scipy.org&#x2F;EricsBroadcastingDoc&quot;&gt;解释&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;支持广播机制的函数是全局函数。哪些是全局函数可以在&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;numpy&#x2F;reference&#x2F;ufuncs.html#available-ufuncs&quot;&gt;文档&lt;&#x2F;a&gt;中查找。&lt;&#x2F;p&gt;
&lt;p&gt;下面是一些广播机制的使用：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np

# Compute outer product of vectors
v = np.array([1,2,3])  # v has shape (3,)
w = np.array([4,5])    # w has shape (2,)
# To compute an outer product, we first reshape v to be a column
# vector of shape (3, 1); we can then broadcast it against w to yield
# an output of shape (3, 2), which is the outer product of v and w:
# [[ 4  5]
#  [ 8 10]
#  [12 15]]
print(np.reshape(v, (3, 1)) * w)

# Add a vector to each row of a matrix
x = np.array([[1,2,3], [4,5,6]])
# x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),
# giving the following matrix:
# [[2 4 6]
#  [5 7 9]]
print(x + v)

# Add a vector to each column of a matrix
# x has shape (2, 3) and w has shape (2,).
# If we transpose x then it has shape (3, 2) and can be broadcast
# against w to yield a result of shape (3, 2); transposing this result
# yields the final result of shape (2, 3) which is the matrix x with
# the vector w added to each column. Gives the following matrix:
# [[ 5  6  7]
#  [ 9 10 11]]
print((x.T + w).T)
# Another solution is to reshape w to be a column vector of shape (2, 1);
# we can then broadcast it directly against x to produce the same
# output.
print(x + np.reshape(w, (2, 1)))

# Multiply a matrix by a constant:
# x has shape (2, 3). Numpy treats scalars as arrays of shape ();
# these can be broadcast together to shape (2, 3), producing the
# following array:
# [[ 2  4  6]
#  [ 8 10 12]]
print(x * 2)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;广播机制能够让你的代码更简洁更迅速，能够用的时候请尽量使用！&lt;&#x2F;p&gt;
&lt;h3 id=&quot;numpy-wen-dang&quot;&gt;Numpy 文档&lt;&#x2F;h3&gt;
&lt;p&gt;这篇教程涉及了你需要了解的numpy中的一些重要内容，但是numpy远不止如此。可以查阅&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;numpy&#x2F;reference&#x2F;&quot;&gt;numpy文献&lt;&#x2F;a&gt;来学习更多。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;scipy&quot;&gt;SciPy&lt;&#x2F;h2&gt;
&lt;p&gt;Numpy提供了高性能的多维数组，以及计算和操作数组的基本工具。SciPy基于Numpy，提供了大量的计算和操作数组的函数，这些函数对于不同类型的科学和工程计算非常有用。&lt;&#x2F;p&gt;
&lt;p&gt;熟悉SciPy的最好方法就是阅读&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;scipy&#x2F;reference&#x2F;index.html&quot;&gt;文档&lt;&#x2F;a&gt;。我们会强调对于本课程有用的部分。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tu-xiang-cao-zuo&quot;&gt;图像操作&lt;&#x2F;h3&gt;
&lt;p&gt;SciPy提供了一些操作图像的基本函数。比如，它提供了将图像从硬盘读入到数组的函数，也提供了将数组中数据写入的硬盘成为图像的函数。下面是一个简单的例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;from scipy.misc import imread, imsave, imresize

# Read an JPEG image into a numpy array
img = imread(&amp;#x27;assets&amp;#x2F;cat.jpg&amp;#x27;)
print(img.dtype, img.shape)  # Prints &amp;quot;uint8 (400, 248, 3)&amp;quot;

# We can tint the image by scaling each of the color channels
# by a different scalar constant. The image has shape (400, 248, 3);
# we multiply it by the array [1, 0.95, 0.9] of shape (3,);
# numpy broadcasting means that this leaves the red channel unchanged,
# and multiplies the green and blue channels by 0.95 and 0.9
# respectively.
img_tinted = img * [1, 0.95, 0.9]

# Resize the tinted image to be 300 by 300 pixels.
img_tinted = imresize(img_tinted, (300, 300))

# Write the tinted image back to disk
imsave(&amp;#x27;assets&amp;#x2F;cat_tinted.jpg&amp;#x27;, img_tinted)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;figure&gt;
&lt;img width=&quot;35%&quot; src=&quot;.&#x2F;cat.jpg&quot; &#x2F;&gt;
&lt;img width=&quot;35%&quot; src=&quot;.&#x2F;cat_tinted.jpg&quot; &#x2F;&gt;
&lt;br&gt;
&lt;p style=&quot;font-size:14px;&quot;&gt;_左边是原始图片，右边是变色和变形的图片_&lt;&#x2F;p&gt;
&lt;&#x2F;figure&gt;
&lt;h3 id=&quot;matlabwen-jian&quot;&gt;MATLAB文件&lt;&#x2F;h3&gt;
&lt;p&gt;函数&lt;code&gt;scipy.io.loadmat&lt;&#x2F;code&gt;和&lt;code&gt;scipy.io.savemat&lt;&#x2F;code&gt;能够让你读和写MATLAB文件。具体请查看&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;scipy&#x2F;reference&#x2F;io.html&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dian-zhi-jian-de-ju-chi&quot;&gt;点之间的距离&lt;&#x2F;h3&gt;
&lt;p&gt;SciPy定义了一些有用的函数，可以计算集合中点之间的距离。&lt;&#x2F;p&gt;
&lt;p&gt;函数&lt;code&gt;scipy.spatial.distance.pdist&lt;&#x2F;code&gt;能够计算集合中所有两点之间的距离：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np
from scipy.spatial.distance import pdist, squareform

# Create the following array where each row is a point in 2D space:
# [[0 1]
#  [1 0]
#  [2 0]]
x = np.array([[0, 1], [1, 0], [2, 0]])
print(x)

# Compute the Euclidean distance between all rows of x.
# d[i, j] is the Euclidean distance between x[i, :] and x[j, :],
# and d is the following array:
# [[ 0.          1.41421356  2.23606798]
#  [ 1.41421356  0.          1.        ]
#  [ 2.23606798  1.          0.        ]]
d = squareform(pdist(x, &amp;#x27;euclidean&amp;#x27;))
print(d)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;具体细节请阅读&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;scipy&#x2F;reference&#x2F;generated&#x2F;scipy.spatial.distance.pdist.html&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;函数&lt;code&gt;scipy.spatial.distance.cdist&lt;&#x2F;code&gt;可以计算不同集合中点的距离，具体请查看&lt;a href=&quot;http:&#x2F;&#x2F;docs.scipy.org&#x2F;doc&#x2F;scipy&#x2F;reference&#x2F;generated&#x2F;scipy.spatial.distance.cdist.html&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;matplotlib&quot;&gt;Matplotlib&lt;&#x2F;h2&gt;
&lt;p&gt;Matplotlib是一个作图库。这里简要介绍&#x27;matplotlib.pyplot&#x27;模块，功能和MATLAB的作图功能类似。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;plotting&quot;&gt;Plotting&lt;&#x2F;h3&gt;
&lt;p&gt;matplotlib库中最重要的函数是&lt;code&gt;Plot&lt;&#x2F;code&gt;。该函数允许你做出2D图形，如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

# Compute the x and y coordinates for points on a sine curve
x = np.arange(0, 3 * np.pi, 0.1)
y = np.sin(x)

# Plot the points using matplotlib
plt.plot(x, y)
plt.show()  # You must call plt.show() to make graphics appear.
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;sine.png&quot;&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;只需要少量工作，就可以一次画不同的线，加上标签，坐标轴标志等。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

# Compute the x and y coordinates for points on sine and cosine curves
x = np.arange(0, 3 * np.pi, 0.1)
y_sin = np.sin(x)
y_cos = np.cos(x)

# Plot the points using matplotlib
plt.plot(x, y_sin)
plt.plot(x, y_cos)
plt.xlabel(&amp;#x27;x axis label&amp;#x27;)
plt.ylabel(&amp;#x27;y axis label&amp;#x27;)
plt.title(&amp;#x27;Sine and Cosine&amp;#x27;)
plt.legend([&amp;#x27;Sine&amp;#x27;, &amp;#x27;Cosine&amp;#x27;])
plt.show()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;sine_cosine.png&quot;&gt;
&lt;&#x2F;figure&gt;
&lt;h3 id=&quot;subplots&quot;&gt;Subplots&lt;&#x2F;h3&gt;
&lt;p&gt;可以使用&lt;code&gt;subplot&lt;&#x2F;code&gt;函数来在一幅图中画不同的东西：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np
import matplotlib.pyplot as plt

# Compute the x and y coordinates for points on sine and cosine curves
x = np.arange(0, 3 * np.pi, 0.1)
y_sin = np.sin(x)
y_cos = np.cos(x)

# Set up a subplot grid that has height 2 and width 1,
# and set the first such subplot as active.
plt.subplot(2, 1, 1)

# Make the first plot
plt.plot(x, y_sin)
plt.title(&amp;#x27;Sine&amp;#x27;)

# Set the second subplot as active, and make the second plot.
plt.subplot(2, 1, 2)
plt.plot(x, y_cos)
plt.title(&amp;#x27;Cosine&amp;#x27;)

# Show the figure.
plt.show()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;sine_cosine_subplot.png&quot;&gt;
&lt;&#x2F;figure&gt;
&lt;p&gt;关于&lt;code&gt;subplot&lt;&#x2F;code&gt;的更多细节，可以阅读&lt;a href=&quot;http:&#x2F;&#x2F;matplotlib.org&#x2F;api&#x2F;pyplot_api.html#matplotlib.pyplot.subplot&quot;&gt;文档&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;images&quot;&gt;Images&lt;&#x2F;h3&gt;
&lt;p&gt;你可以使用&lt;code&gt;imshow&lt;&#x2F;code&gt;函数来显示图像，如下所示：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;import numpy as np
from scipy.misc import imread, imresize
import matplotlib.pyplot as plt

img = imread(&amp;#x27;assets&amp;#x2F;cat.jpg&amp;#x27;)
img_tinted = img * [1, 0.95, 0.9]

# Show the original image
plt.subplot(1, 2, 1)
plt.imshow(img)

# Show the tinted image
plt.subplot(1, 2, 2)

# A slight gotcha with imshow is that it might give strange results
# if presented with data that is not uint8. To work around this, we
# explicitly cast the image to uint8 before displaying it.
plt.imshow(np.uint8(img_tinted))
plt.show()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;figure&gt;
&lt;img src=&quot;.&#x2F;cat_tinted_imshow.png&quot;&gt;
&lt;&#x2F;figure&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Markdown 数学公式指导手册</title>
        <published>2017-05-11T00:00:00+00:00</published>
        <updated>2023-03-23T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="/blog/mathjax/"/>
        <id>/blog/mathjax/</id>
        
        <summary type="html">&lt;p&gt;本手册的主要内容来自 &lt;a href=&quot;https:&#x2F;&#x2F;math.meta.stackexchange.com&#x2F;questions&#x2F;5020&#x2F;mathjax-basic-tutorial-and-quick-reference&quot;&gt;mathjax-basic-tutorial-and-quick-reference&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;用 Katex 改写数学公式，发现 右括号接下标，不能正常解析，&lt;code&gt;)&lt;&#x2F;code&gt;改成 &lt;code&gt;\rparen&lt;&#x2F;code&gt;, &lt;code&gt;]&lt;&#x2F;code&gt;改成 &lt;code&gt;\rbrack&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Pandoc&#x27;s Markdown 語法中文翻譯</title>
        <published>2017-05-11T00:00:00+00:00</published>
        <updated>2017-05-11T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="/blog/pandoc/"/>
        <id>/blog/pandoc/</id>
        
        <summary type="html">&lt;h2 id=&quot;qian-yan&quot;&gt;前言&lt;&#x2F;h2&gt;
&lt;p&gt;這份文件是 &lt;a href=&quot;http:&#x2F;&#x2F;johnmacfarlane.net&#x2F;pandoc&#x2F;&quot;&gt;Pandoc&lt;&#x2F;a&gt; 版本 Markdown 語法的中文翻譯。Pandoc 本身是由 &lt;a href=&quot;http:&#x2F;&#x2F;johnmacfarlane.net&#x2F;&quot;&gt;John MacFarlane&lt;&#x2F;a&gt; 所開發的文件轉換工具，可以在 HTML, Markdown, PDF, TeX...等等格式之間進行轉換。有許多喜歡純文字編輯的人，利用 Pandoc 來進行論文的撰寫或投影片製作。但除了轉換的功能外，Pandoc 所定義的 Markdown 擴充語法也是這套工具的一大亮點，在 Pandoc 的官方使用說明文件中，光是其針對 Markdown 格式的擴充就佔了整整一半左右的篇幅。&lt;&#x2F;p&gt;
</summary>
        
    </entry>
</feed>
