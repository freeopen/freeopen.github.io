<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Python Numpy 教程 | Freeopen</title>
  <meta name="title" content="Python Numpy 教程">
<meta name="description" content="7 labo.">
<meta name="referrer" content="strict-origin-when-cross-origin">
  <link href="/main.css" rel="stylesheet">
</head>
<body>
  <header>
  <a href="/" class="title">
    <h1>Freeopen</h1>
  </a>
  <nav aria-label="site">
      <a href="/">Home</a>
      <a href="/blog/">Blog</a>
      <a href="/shorttips/">Tips</a>
      <a href="/about/">About</a>
  </nav>
</header>


  <div>
      
<aside id="toc-aside" class="right-to-left">
        <h2>Table of contents</h2>
    <ol>
        <li>
            <a href="#introduction">Introduction</a>
            
        </li><li>
            <a href="#basics-of-python">Basics of Python</a>
            <ol>
                <li>
                    <a href="#python-versions">Python versions</a>
                </li><li>
                    <a href="#basic-data-types">Basic data types</a>
                </li><li>
                    <a href="#containers">Containers</a>
                </li><li>
                    <a href="#functions">Functions</a>
                </li><li>
                    <a href="#classes">Classes</a>
                </li>
            </ol>
        </li><li>
            <a href="#numpy">Numpy</a>
            <ol>
                <li>
                    <a href="#arrays">Arrays</a>
                </li><li>
                    <a href="#array-indexing">Array indexing</a>
                </li><li>
                    <a href="#datatypes">Datatypes</a>
                </li><li>
                    <a href="#array-math">Array math</a>
                </li><li>
                    <a href="#broadcasting">Broadcasting</a>
                </li><li>
                    <a href="#numpy-wen-dang">Numpy 文档</a>
                </li>
            </ol>
        </li><li>
            <a href="#scipy">SciPy</a>
            <ol>
                <li>
                    <a href="#tu-xiang-cao-zuo">图像操作</a>
                </li><li>
                    <a href="#matlabwen-jian">MATLAB文件</a>
                </li><li>
                    <a href="#dian-zhi-jian-de-ju-chi">点之间的距离</a>
                </li>
            </ol>
        </li><li>
            <a href="#matplotlib">Matplotlib</a>
            <ol>
                <li>
                    <a href="#plotting">Plotting</a>
                </li><li>
                    <a href="#subplots">Subplots</a>
                </li><li>
                    <a href="#images">Images</a>
                </li>
            </ol>
        </li>
        <li class="toc-comments-link"><a href="#comments">Comments</a></li>
    </ol>
</aside>

      <h1>Python Numpy 教程</h1>
      <time datetime="2017-12-11" class="post-date">
          2017-12-11
          
            (updated on 2017-12-11)
          
      </time>
  <main>
    <p><a href="http://cs231n.github.io/python-numpy-tutorial/">原文</a> | <a href="https://zhuanlan.zhihu.com/p/20878530?refer=intelligentunit">原译文</a></p>
<blockquote>
<p>freeopen: 原译文没有目录导航，阅读起来不方便。补全少量漏翻的地方。虽然内容很基础，但需要时快速查阅一下还是很不错的。</p>
</blockquote>
<h2 id="introduction">Introduction</h2>
<p>Python是一门伟大的通用编程语言，在一些常用库（numpy, scipy, matplotlib）的帮助下，它又会变成一个强大的科学计算环境。</p>
<p>我们期望你们中大多数人对于Python语言和Numpy库比较熟悉，而对于没有Python经验的同学，这篇教程可以帮助你们快速了解Python编程环境和如何使用Python作为科学计算工具。</p>
<p>一部分同学对于Matlab有一定经验。对于这部分同学，我们推荐阅读 <a href="https://docs.scipy.org/doc/numpy-dev/user/numpy-for-matlab-users.html">numpy for Matlab users 页面</a>。</p>
<p>本教程内容涵盖:</p>
<ul>
<li>Basic Python: Basic data types (Containers, Lists, Dictionaries, Sets, Tuples), Functions, Classes</li>
<li>Numpy: Arrays, Array indexing, Datatypes, Array math, Broadcasting</li>
<li>SciPy: Image operations, MATLAB files, Distance between points,</li>
<li>Matplotlib: Plotting, Subplots, Images</li>
</ul>
<h2 id="basics-of-python">Basics of Python</h2>
<p>Python是一种高级的，动态类型的多范型编程语言。很多时候，大家会说Python看起来简直和伪代码一样，这是因为你能够通过很少行数的代码表达出很有力的思想。举个例子，下面是用Python实现的经典的quicksort算法例子：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def quicksort(arr):
    if len(arr) &lt;= 1:
        return arr
    pivot = arr[len(arr) &#x2F;&#x2F; 2]
    left = [x for x in arr if x &lt; pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x &gt; pivot]
    return quicksort(left) + middle + quicksort(right)

print quicksort([3,6,8,10,1,2,1])
# Prints &quot;[1, 1, 2, 3, 6, 8, 10]&quot;
</code></pre>
<h3 id="python-versions">Python versions</h3>
<p>Python有两个支持的版本，分别是2.7和3.4。这有点让人迷惑，3.0向语言中引入了很多不向后兼容的变化，2.7下的代码有时候在3.4下是行不通的。在这个课程中，我们使用的是2.7版本。</p>
<p>如何查看版本呢？使用<code>python --version</code>命令。</p>
<h3 id="basic-data-types">Basic data types</h3>
<p>和大多数编程语言一样，Python拥有一系列的基本数据类型，比如整型、浮点型、布尔型和字符串等。这些类型的使用方式和在其他语言中的使用方式是类似的。</p>
<p><strong>Numbers</strong>: 整型和浮点型的使用与其他语言类似。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">x = 3
print(type(x)) # Prints &quot;&lt;class &#x27;int&#x27;&gt;&quot;
print(x)       # Prints &quot;3&quot;
print(x + 1)   # Addition; prints &quot;4&quot;
print(x - 1)   # Subtraction; prints &quot;2&quot;
print(x * 2)   # Multiplication; prints &quot;6&quot;
print(x ** 2)  # Exponentiation; prints &quot;9&quot;
x += 1
print(x)  # Prints &quot;4&quot;
x *= 2
print(x)  # Prints &quot;8&quot;
y = 2.5
print(type(y)) # Prints &quot;&lt;class &#x27;float&#x27;&gt;&quot;
print(y, y + 1, y * 2, y ** 2) # Prints &quot;2.5 3.5 5.0 6.25&quot;
</code></pre>
<p>需要注意的是，Python中没有 <code>x++</code> 和 <code>x--</code> 的操作符。</p>
<p>Python也有内置的长整型和复杂数字类型，具体细节可以查看<a href="https://docs.python.org/2/library/stdtypes.html#numeric-types-int-float-long-complex">文档</a>。</p>
<p><strong>Booleans</strong>: Python实现了所有的布尔逻辑，但用的是英语，而不是我们习惯的操作符（比如<code>&amp;&amp;</code>和<code>||</code>等）。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">t = True
f = False
print(type(t)) # Prints &quot;&lt;class &#x27;bool&#x27;&gt;&quot;
print(t and f) # Logical AND; prints &quot;False&quot;
print(t or f)  # Logical OR; prints &quot;True&quot;
print(not t)   # Logical NOT; prints &quot;False&quot;
print(t != f)  # Logical XOR; prints &quot;True&quot;
</code></pre>
<p><strong>Strings</strong>: Python对字符串的支持非常棒。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">hello = &#x27;hello&#x27;    # String literals can use single quotes
world = &quot;world&quot;    # or double quotes; it does not matter.
print(hello)       # Prints &quot;hello&quot;
print(len(hello))  # String length; prints &quot;5&quot;
hw = hello + &#x27; &#x27; + world  # String concatenation
print(hw)  # prints &quot;hello world&quot;
hw12 = &#x27;%s %s %d&#x27; % (hello, world, 12)  # sprintf style string formatting
print(hw12)  # prints &quot;hello world 12&quot;
</code></pre>
<p>字符串对象有一系列有用的方法，比如：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">s = &quot;hello&quot;
print(s.capitalize())  # Capitalize a string; prints &quot;Hello&quot;
print(s.upper())       # Convert a string to uppercase; prints &quot;HELLO&quot;
print(s.rjust(7))      # Right-justify a string, padding with spaces; prints &quot;  hello&quot;
print(s.center(7))     # Center a string, padding with spaces; prints &quot; hello &quot;
print(s.replace(&#x27;l&#x27;, &#x27;(ell)&#x27;))  # Replace all instances of one substring with another;
                                # prints &quot;he(ell)(ell)o&quot;
print(&#x27;  world &#x27;.strip())  # Strip leading and trailing whitespace; prints &quot;world&quot;
</code></pre>
<p>如果想详细查看字符串方法，请看<a href="https://docs.python.org/2/library/stdtypes.html#string-methods">文档</a>。</p>
<h3 id="containers">Containers</h3>
<p>Python有以下几种容器类型：列表（lists）、字典（dictionaries）、集合（sets）和元组（tuples）。</p>
<h4 id="lists">Lists</h4>
<p>列表就是Python中的数组，但是列表长度可变，且能包含不同类型元素。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">xs = [3, 1, 2]    # Create a list
print(xs, xs[2])  # Prints &quot;[3, 1, 2] 2&quot;
print(xs[-1])     # Negative indices count from the end of the list; prints &quot;2&quot;
xs[2] = &#x27;foo&#x27;     # Lists can contain elements of different types
print(xs)         # Prints &quot;[3, 1, &#x27;foo&#x27;]&quot;
xs.append(&#x27;bar&#x27;)  # Add a new element to the end of the list
print(xs)         # Prints &quot;[3, 1, &#x27;foo&#x27;, &#x27;bar&#x27;]&quot;
x = xs.pop()      # Remove and return the last element of the list
print(x, xs)      # Prints &quot;bar [3, 1, &#x27;foo&#x27;]&quot;
</code></pre>
<p>列表的细节，同样可以查阅<a href="https://docs.python.org/2/tutorial/datastructures.html#more-on-lists">文档</a>.。</p>
<p><strong>Slicing</strong>: 为了一次性地获取列表中的元素，Python提供了一种简洁的语法，这就是切片。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">nums = list(range(5))     # range is a built-in function that creates a list of integers
print(nums)               # Prints &quot;[0, 1, 2, 3, 4]&quot;
print(nums[2:4])          # Get a slice from index 2 to 4 (exclusive); prints &quot;[2, 3]&quot;
print(nums[2:])           # Get a slice from index 2 to the end; prints &quot;[2, 3, 4]&quot;
print(nums[:2])           # Get a slice from the start to index 2 (exclusive); prints &quot;[0, 1]&quot;
print(nums[:])            # Get a slice of the whole list; prints &quot;[0, 1, 2, 3, 4]&quot;
print(nums[:-1])          # Slice indices can be negative; prints &quot;[0, 1, 2, 3]&quot;
nums[2:4] = [8, 9]        # Assign a new sublist to a slice
print(nums)               # Prints &quot;[0, 1, 8, 9, 4]&quot;
</code></pre>
<p><strong>Loops</strong>: 我们可以这样遍历列表中的每一个元素：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">animals = [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;monkey&#x27;]
for animal in animals:
    print(animal)
# Prints &quot;cat&quot;, &quot;dog&quot;, &quot;monkey&quot;, each on its own line.
</code></pre>
<p>如果想要在循环体内访问每个元素的指针，可以使用内置的<code>enumerate</code>函数</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">animals = [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;monkey&#x27;]
for idx, animal in enumerate(animals):
    print(&#x27;#%d: %s&#x27; % (idx + 1, animal))
# Prints &quot;#1: cat&quot;, &quot;#2: dog&quot;, &quot;#3: monkey&quot;, each on its own line
</code></pre>
<p><strong>List comprehensions</strong>: 在编程的时候，我们常常想要将一种数据类型转换为另一种。下面是一个简单例子，将列表中的每个元素变成它的平方。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">nums = [0, 1, 2, 3, 4]
squares = []
for x in nums:
    squares.append(x ** 2)
print(squares)   # Prints [0, 1, 4, 9, 16]
</code></pre>
<p>使用列表推导，你就可以让代码简化很多：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">nums = [0, 1, 2, 3, 4]
squares = [x ** 2 for x in nums]
print(squares)   # Prints [0, 1, 4, 9, 16]
</code></pre>
<p>列表推导还可以包含条件：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">nums = [0, 1, 2, 3, 4]
even_squares = [x ** 2 for x in nums if x % 2 == 0]
print(even_squares)  # Prints &quot;[0, 4, 16]&quot;
</code></pre>
<h4 id="dictionaries">Dictionaries</h4>
<p>字典用来储存（键, 值）对，这和Java中的<code>Map</code>差不多。你可以这样使用它：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">d = {&#x27;cat&#x27;: &#x27;cute&#x27;, &#x27;dog&#x27;: &#x27;furry&#x27;}  # Create a new dictionary with some data
print(d[&#x27;cat&#x27;])       # Get an entry from a dictionary; prints &quot;cute&quot;
print(&#x27;cat&#x27; in d)     # Check if a dictionary has a given key; prints &quot;True&quot;
d[&#x27;fish&#x27;] = &#x27;wet&#x27;     # Set an entry in a dictionary
print(d[&#x27;fish&#x27;])      # Prints &quot;wet&quot;
# print(d[&#x27;monkey&#x27;])  # KeyError: &#x27;monkey&#x27; not a key of d
print(d.get(&#x27;monkey&#x27;, &#x27;N&#x2F;A&#x27;))  # Get an element with a default; prints &quot;N&#x2F;A&quot;
print(d.get(&#x27;fish&#x27;, &#x27;N&#x2F;A&#x27;))    # Get an element with a default; prints &quot;wet&quot;
del d[&#x27;fish&#x27;]         # Remove an element from a dictionary
print(d.get(&#x27;fish&#x27;, &#x27;N&#x2F;A&#x27;)) # &quot;fish&quot; is no longer a key; prints &quot;N&#x2F;A&quot;
</code></pre>
<p>想要知道字典的其他特性，请查阅<a href="https://docs.python.org/2/library/stdtypes.html#dict">文档</a>。</p>
<p><strong>Loops</strong>：在字典中，用键来迭代更加容易。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">d = {&#x27;person&#x27;: 2, &#x27;cat&#x27;: 4, &#x27;spider&#x27;: 8}
for animal in d:
    legs = d[animal]
    print(&#x27;A %s has %d legs&#x27; % (animal, legs))
# Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;
</code></pre>
<p>如果你想要访问键和对应的值，那就使用<code>iteritems</code>方法：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">d = {&#x27;person&#x27;: 2, &#x27;cat&#x27;: 4, &#x27;spider&#x27;: 8}
for animal, legs in d.items():
    print(&#x27;A %s has %d legs&#x27; % (animal, legs))
# Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;
</code></pre>
<p><strong>Dictionary comprehensions</strong>：和列表推导类似，但是允许你方便地构建字典。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">nums = [0, 1, 2, 3, 4]
even_num_to_square = {x: x ** 2 for x in nums if x % 2 == 0}
print(even_num_to_square)  # Prints &quot;{0: 0, 2: 4, 4: 16}&quot;
</code></pre>
<h4 id="sets">Sets</h4>
<p>集合是独立不同个体的无序集合。示例如下：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">animals = {&#x27;cat&#x27;, &#x27;dog&#x27;}
print(&#x27;cat&#x27; in animals)   # Check if an element is in a set; prints &quot;True&quot;
print(&#x27;fish&#x27; in animals)  # prints &quot;False&quot;
animals.add(&#x27;fish&#x27;)       # Add an element to a set
print(&#x27;fish&#x27; in animals)  # Prints &quot;True&quot;
print(len(animals))       # Number of elements in a set; prints &quot;3&quot;
animals.add(&#x27;cat&#x27;)        # Adding an element that is already in the set does nothing
print(len(animals))       # Prints &quot;3&quot;
animals.remove(&#x27;cat&#x27;)     # Remove an element from a set
print(len(animals))       # Prints &quot;2&quot;
</code></pre>
<p>和前面一样，要知道更详细的，查看<a href="https://docs.python.org/3.5/library/stdtypes.html#set">文档</a>.</p>
<p><strong>Loops</strong>：在集合中循环的语法和在列表中一样，但是集合是无序的，所以你在访问集合的元素的时候，不能做关于顺序的假设。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">animals = {&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;fish&#x27;}
for idx, animal in enumerate(animals):
    print(&#x27;#%d: %s&#x27; % (idx + 1, animal))
# Prints &quot;#1: fish&quot;, &quot;#2: dog&quot;, &quot;#3: cat&quot;
</code></pre>
<p><strong>Set comprehensions</strong>：和字典推导一样，可以很方便地构建集合：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from math import sqrt
nums = {int(sqrt(x)) for x in range(30)}
print(nums)  # Prints &quot;{0, 1, 2, 3, 4, 5}&quot;
</code></pre>
<h4 id="tuples">Tuples</h4>
<p>元组是一个值的有序列表（不可改变）。从很多方面来说，元组和列表都很相似。和列表最重要的不同在于，元组可以在字典中用作键，还可以作为集合的元素，而列表不行。例子如下：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">d = {(x, x + 1): x for x in range(10)}  # Create a dictionary with tuple keys
t = (5, 6)        # Create a tuple
print(type(t))    # Prints &quot;&lt;class &#x27;tuple&#x27;&gt;&quot;
print(d[t])       # Prints &quot;5&quot;
print(d[(1, 2)])  # Prints &quot;1&quot;
</code></pre>
<p><a href="https://docs.python.org/3.5/tutorial/datastructures.html#tuples-and-sequences">文档</a>有更多元组的信息。</p>
<h3 id="functions">Functions</h3>
<p>Python函数使用<code>def</code>来定义函数：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def sign(x):
    if x &gt; 0:
        return &#x27;positive&#x27;
    elif x &lt; 0:
        return &#x27;negative&#x27;
    else:
        return &#x27;zero&#x27;

for x in [-1, 0, 1]:
    print(sign(x))
# Prints &quot;negative&quot;, &quot;zero&quot;, &quot;positive&quot;
</code></pre>
<p>我们常常使用可选参数来定义函数：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def hello(name, loud=False):
    if loud:
        print(&#x27;HELLO, %s!&#x27; % name.upper())
    else:
        print(&#x27;Hello, %s&#x27; % name)

hello(&#x27;Bob&#x27;) # Prints &quot;Hello, Bob&quot;
hello(&#x27;Fred&#x27;, loud=True)  # Prints &quot;HELLO, FRED!&quot;
</code></pre>
<h3 id="classes">Classes</h3>
<p>Python对于类的定义是简单直接的：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">class Greeter(object):

    # Constructor
    def __init__(self, name):
        self.name = name  # Create an instance variable

    # Instance method
    def greet(self, loud=False):
        if loud:
            print(&#x27;HELLO, %s!&#x27; % self.name.upper())
        else:
            print(&#x27;Hello, %s&#x27; % self.name)

g = Greeter(&#x27;Fred&#x27;)  # Construct an instance of the Greeter class
g.greet()            # Call an instance method; prints &quot;Hello, Fred&quot;
g.greet(loud=True)   # Call an instance method; prints &quot;HELLO, FRED!&quot;
</code></pre>
<p>更多类的信息请查阅<a href="https://docs.python.org/3.5/tutorial/classes.html">文档</a>。</p>
<h2 id="numpy">Numpy</h2>
<p><a href="http://www.numpy.org/">Numpy</a>是Python中用于科学计算的核心库。它提供了高性能的多维数组对象，以及相关工具。如何熟悉MATLAB, 你可以从这份<a href="http://wiki.scipy.org/NumPy_for_Matlab_Users">教程</a>开始学习Numpy.</p>
<h3 id="arrays">Arrays</h3>
<p>一个numpy数组是一个由不同数值组成的网格。网格中的数据都是同一种数据类型，可以通过非负整型数的元组来访问。维度的数量被称为数组的阶，数组的大小是一个由整型数构成的元组，可以描述数组不同维度上的大小。</p>
<p>我们可以从列表创建数组，然后利用方括号访问其中的元素：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

a = np.array([1, 2, 3])   # Create a rank 1 array
print(type(a))            # Prints &quot;&lt;class &#x27;numpy.ndarray&#x27;&gt;&quot;
print(a.shape)            # Prints &quot;(3,)&quot;
print(a[0], a[1], a[2])   # Prints &quot;1 2 3&quot;
a[0] = 5                  # Change an element of the array
print(a)                  # Prints &quot;[5, 2, 3]&quot;

b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 array
print(b.shape)                     # Prints &quot;(2, 3)&quot;
print(b[0, 0], b[0, 1], b[1, 0])   # Prints &quot;1 2 4&quot;
</code></pre>
<p>Numpy还提供了很多其他创建数组的方法：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

a = np.zeros((2,2))   # Create an array of all zeros
print(a)              # Prints &quot;[[ 0.  0.]
                      #          [ 0.  0.]]&quot;

b = np.ones((1,2))    # Create an array of all ones
print(b)              # Prints &quot;[[ 1.  1.]]&quot;

c = np.full((2,2), 7)  # Create a constant array
print(c)               # Prints &quot;[[ 7.  7.]
                       #          [ 7.  7.]]&quot;

d = np.eye(2)         # Create a 2x2 identity matrix
print(d)              # Prints &quot;[[ 1.  0.]
                      #          [ 0.  1.]]&quot;

e = np.random.random((2,2))  # Create an array filled with random values
print(e)                     # Might print &quot;[[ 0.91940167  0.08143941]
                             #               [ 0.68744134  0.87236687]]&quot;
</code></pre>
<p>其他数组相关方法，请查看<a href="http://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation">文档</a>。</p>
<h3 id="array-indexing">Array indexing</h3>
<p>Numpy提供了多种访问数组的方法。</p>
<p><strong>Slicing</strong>：和Python列表类似，numpy数组可以使用切片语法。因为数组可以是多维的，所以你必须为每个维度指定好切片。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Use slicing to pull out the subarray consisting of the first 2 rows
# and columns 1 and 2; b is the following array of shape (2, 2):
# [[2 3]
#  [6 7]]
b = a[:2, 1:3]

# A slice of an array is a view into the same data, so modifying it
# will modify the original array.
print(a[0, 1])   # Prints &quot;2&quot;
b[0, 0] = 77     # b[0, 0] is the same piece of data as a[0, 1]
print(a[0, 1])   # Prints &quot;77&quot;
</code></pre>
<p>你可以同时使用整型和切片语法来访问数组。但是，这样做会产生一个比原数组低阶的新数组。需要注意的是，这里和MATLAB中的情况是不同的：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# Two ways of accessing the data in the middle row of the array.
# Mixing integer indexing with slices yields an array of lower rank,
# while using only slices yields an array of the same rank as the
# original array:
row_r1 = a[1, :]    # Rank 1 view of the second row of a
row_r2 = a[1:2, :]  # Rank 2 view of the second row of a
print(row_r1, row_r1.shape)  # Prints &quot;[5 6 7 8] (4,)&quot;
print(row_r2, row_r2.shape)  # Prints &quot;[[5 6 7 8]] (1, 4)&quot;

# We can make the same distinction when accessing columns of an array:
col_r1 = a[:, 1]
col_r2 = a[:, 1:2]
print(col_r1, col_r1.shape)  # Prints &quot;[ 2  6 10] (3,)&quot;
print(col_r2, col_r2.shape)  # Prints &quot;[[ 2]
                             #          [ 6]
                             #          [10]] (3, 1)&quot;
</code></pre>
<p><strong>Integer array indexing</strong>：当我们使用切片语法访问数组时，得到的总是原数组的一个子集。整型数组访问允许我们利用其它数组的数据构建一个新的数组：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

a = np.array([[1,2], [3, 4], [5, 6]])

# An example of integer array indexing.
# The returned array will have shape (3,) and
print(a[[0, 1, 2], [0, 1, 0]])  # Prints &quot;[1 4 5]&quot;

# The above example of integer array indexing is equivalent to this:
print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints &quot;[1 4 5]&quot;

# When using integer array indexing, you can reuse the same
# element from the source array:
print(a[[0, 0], [1, 1]])  # Prints &quot;[2 2]&quot;

# Equivalent to the previous integer array indexing example
print(np.array([a[0, 1], a[0, 1]]))  # Prints &quot;[2 2]&quot;
</code></pre>
<p>整型数组访问语法还有个有用的技巧，可以用来选择或者更改矩阵中每行中的一个元素：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

# Create a new array from which we will select elements
a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])

print(a)  # prints &quot;array([[ 1,  2,  3],
          #                [ 4,  5,  6],
          #                [ 7,  8,  9],
          #                [10, 11, 12]])&quot;

# Create an array of indices
b = np.array([0, 2, 0, 1])

# Select one element from each row of a using the indices in b
print(a[np.arange(4), b])  # Prints &quot;[ 1  6  7 11]&quot;

# Mutate one element from each row of a using the indices in b
a[np.arange(4), b] += 10

print(a)  # prints &quot;array([[11,  2,  3],
          #                [ 4,  5, 16],
          #                [17,  8,  9],
          #                [10, 21, 12]])
</code></pre>
<p><strong>Boolean array indexing</strong>：布尔型数组访问可以让你选择数组中任意元素。通常，这种访问方式用于选取数组中满足某些条件的元素，举例如下：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

a = np.array([[1,2], [3, 4], [5, 6]])

bool_idx = (a &gt; 2)   # Find the elements of a that are bigger than 2;
                     # this returns a numpy array of Booleans of the same
                     # shape as a, where each slot of bool_idx tells
                     # whether that element of a is &gt; 2.

print(bool_idx)      # Prints &quot;[[False False]
                     #          [ True  True]
                     #          [ True  True]]&quot;

# We use boolean array indexing to construct a rank 1 array
# consisting of the elements of a corresponding to the True values
# of bool_idx
print(a[bool_idx])  # Prints &quot;[3 4 5 6]&quot;

# We can do all of the above in a single concise statement:
print(a[a &gt; 2])     # Prints &quot;[3 4 5 6]&quot;
</code></pre>
<p>为了教程的简短，有很多数组访问的细节我们没有详细说明，可以查看<a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html">文档</a>。</p>
<h3 id="datatypes">Datatypes</h3>
<p>每个Numpy数组都是数据类型相同的元素组成的网格。Numpy提供了很多的数据类型用于创建数组。当你创建数组的时候，Numpy会尝试猜测数组的数据类型，你也可以通过参数直接指定数据类型，例子如下：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

x = np.array([1, 2])   # Let numpy choose the datatype
print(x.dtype)         # Prints &quot;int64&quot;

x = np.array([1.0, 2.0])   # Let numpy choose the datatype
print(x.dtype)             # Prints &quot;float64&quot;

x = np.array([1, 2], dtype=np.int64)   # Force a particular datatype
print(x.dtype)                         # Prints &quot;int64&quot;
</code></pre>
<p>更多细节查看<a href="http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html">文档</a>。</p>
<h3 id="array-math">Array math</h3>
<p>基本数学计算函数会对数组中元素逐个进行计算，既可以利用操作符重载，也可以使用函数方式：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

x = np.array([[1,2],[3,4]], dtype=np.float64)
y = np.array([[5,6],[7,8]], dtype=np.float64)

# Elementwise sum; both produce the array
# [[ 6.0  8.0]
#  [10.0 12.0]]
print(x + y)
print(np.add(x, y))

# Elementwise difference; both produce the array
# [[-4.0 -4.0]
#  [-4.0 -4.0]]
print(x - y)
print(np.subtract(x, y))

# Elementwise product; both produce the array
# [[ 5.0 12.0]
#  [21.0 32.0]]
print(x * y)
print(np.multiply(x, y))

# Elementwise division; both produce the array
# [[ 0.2         0.33333333]
#  [ 0.42857143  0.5       ]]
print(x &#x2F; y)
print(np.divide(x, y))

# Elementwise square root; produces the array
# [[ 1.          1.41421356]
#  [ 1.73205081  2.        ]]
print(np.sqrt(x))
</code></pre>
<p>和MATLAB不同，<code>*</code>是元素逐个相乘，而不是矩阵乘法。在Numpy中使用<code>dot</code>来进行矩阵乘法：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])

v = np.array([9,10])
w = np.array([11, 12])

# Inner product of vectors; both produce 219
print(v.dot(w))
print(np.dot(v, w))

# Matrix &#x2F; vector product; both produce the rank 1 array [29 67]
print(x.dot(v))
print(np.dot(x, v))

# Matrix &#x2F; matrix product; both produce the rank 2 array
# [[19 22]
#  [43 50]]
print(x.dot(y))
print(np.dot(x, y))
</code></pre>
<p>Numpy提供了很多计算数组的函数，其中最常用的一个是'sum'：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

x = np.array([[1,2],[3,4]])

print(np.sum(x))  # Compute sum of all elements; prints &quot;10&quot;
print(np.sum(x, axis=0))  # Compute sum of each column; prints &quot;[4 6]&quot;
print(np.sum(x, axis=1))  # Compute sum of each row; prints &quot;[3 7]&quot;
</code></pre>
<p>想要了解更多函数，可以查看<a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">文档</a>。</p>
<p>除了计算，我们还常常改变数组或者操作其中的元素。其中将矩阵转置是常用的一个，在Numpy中，使用<code>T</code>来转置矩阵：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

x = np.array([[1,2], [3,4]])
print(x)    # Prints &quot;[[1 2]
            #          [3 4]]&quot;
print(x.T)  # Prints &quot;[[1 3]
            #          [2 4]]&quot;

# Note that taking the transpose of a rank 1 array does nothing:
v = np.array([1,2,3])
print(v)    # Prints &quot;[1 2 3]&quot;
print(v.T)  # Prints &quot;[1 2 3]&quot;
</code></pre>
<p>Numpy还提供了更多操作数组的方法，请查看<a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html">文档</a>.</p>
<h3 id="broadcasting">Broadcasting</h3>
<p>广播是一种强有力的机制，它让Numpy可以让不同大小的矩阵在一起进行数学计算。我们常常会有一个小的矩阵和一个大的矩阵，然后我们会需要用小的矩阵对大的矩阵做一些计算。</p>
<p>举个例子，如果我们想要把一个向量加到矩阵的每一行，我们可以这样做：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

# We will add the vector v to each row of the matrix x,
# storing the result in the matrix y
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = np.empty_like(x)   # Create an empty matrix with the same shape as x

# Add the vector v to each row of the matrix x with an explicit loop
for i in range(4):
    y[i, :] = x[i, :] + v

# Now y is the following
# [[ 2  2  4]
#  [ 5  5  7]
#  [ 8  8 10]
#  [11 11 13]]
print(y)
</code></pre>
<p>这样是行得通的，但是当'x'矩阵非常大，利用循环来计算就会变得很慢很慢。我们可以换一种思路：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

# We will add the vector v to each row of the matrix x,
# storing the result in the matrix y
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
vv = np.tile(v, (4, 1))   # Stack 4 copies of v on top of each other
print(vv)                 # Prints &quot;[[1 0 1]
                          #          [1 0 1]
                          #          [1 0 1]
                          #          [1 0 1]]&quot;
y = x + vv  # Add x and vv elementwise
print(y)  # Prints &quot;[[ 2  2  4
          #          [ 5  5  7]
          #          [ 8  8 10]
          #          [11 11 13]]&quot;
</code></pre>
<p>Numpy广播机制可以让我们不用创建<code>vv</code>，就能直接运算，看看下面例子：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

# We will add the vector v to each row of the matrix x,
# storing the result in the matrix y
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = x + v  # Add v to each row of x using broadcasting
print(y)  # Prints &quot;[[ 2  2  4]
          #          [ 5  5  7]
          #          [ 8  8 10]
          #          [11 11 13]]&quot;
</code></pre>
<p><code>y = x + v</code>这一行，即使<code>x</code>的维度为<code>(4, 3)</code>, <code>v</code>的维度为<code>(3,)</code>，但由于广播机制，<code>v</code>在计算时的实际维度为<code>(4, 3)</code>，其中每行是<code>v</code>的副本，然后再每个元素相加求得结果。</p>
<p>对两个数组使用广播机制要遵守下列规则：</p>
<ol>
<li>如果数组的秩不同，使用1来将秩较小的数组进行扩展，直到两个数组的尺寸的长度都一样。</li>
<li>如果两个数组在某个维度上的长度是一样的，或者其中一个数组在该维度上长度为1，那么我们就说这两个数组在该维度上是相容的。</li>
<li>如果两个数组在所有维度上都是相容的，他们就能使用广播。</li>
<li>如果两个输入数组的尺寸不同，那么注意其中较大的那个尺寸。因为广播之后，两个数组的尺寸将和那个较大的尺寸一样。</li>
<li>在任何一个维度上，如果一个数组的长度为1，另一个数组长度大于1，那么在该维度上，就好像是对第一个数组进行了复制。</li>
</ol>
<p>如果上述解释看不明白，可以读一读<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">文档</a>和这个<a href="http://wiki.scipy.org/EricsBroadcastingDoc">解释</a>。</p>
<p>支持广播机制的函数是全局函数。哪些是全局函数可以在<a href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs">文档</a>中查找。</p>
<p>下面是一些广播机制的使用：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np

# Compute outer product of vectors
v = np.array([1,2,3])  # v has shape (3,)
w = np.array([4,5])    # w has shape (2,)
# To compute an outer product, we first reshape v to be a column
# vector of shape (3, 1); we can then broadcast it against w to yield
# an output of shape (3, 2), which is the outer product of v and w:
# [[ 4  5]
#  [ 8 10]
#  [12 15]]
print(np.reshape(v, (3, 1)) * w)

# Add a vector to each row of a matrix
x = np.array([[1,2,3], [4,5,6]])
# x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),
# giving the following matrix:
# [[2 4 6]
#  [5 7 9]]
print(x + v)

# Add a vector to each column of a matrix
# x has shape (2, 3) and w has shape (2,).
# If we transpose x then it has shape (3, 2) and can be broadcast
# against w to yield a result of shape (3, 2); transposing this result
# yields the final result of shape (2, 3) which is the matrix x with
# the vector w added to each column. Gives the following matrix:
# [[ 5  6  7]
#  [ 9 10 11]]
print((x.T + w).T)
# Another solution is to reshape w to be a column vector of shape (2, 1);
# we can then broadcast it directly against x to produce the same
# output.
print(x + np.reshape(w, (2, 1)))

# Multiply a matrix by a constant:
# x has shape (2, 3). Numpy treats scalars as arrays of shape ();
# these can be broadcast together to shape (2, 3), producing the
# following array:
# [[ 2  4  6]
#  [ 8 10 12]]
print(x * 2)
</code></pre>
<p>广播机制能够让你的代码更简洁更迅速，能够用的时候请尽量使用！</p>
<h3 id="numpy-wen-dang">Numpy 文档</h3>
<p>这篇教程涉及了你需要了解的numpy中的一些重要内容，但是numpy远不止如此。可以查阅<a href="http://docs.scipy.org/doc/numpy/reference/">numpy文献</a>来学习更多。</p>
<h2 id="scipy">SciPy</h2>
<p>Numpy提供了高性能的多维数组，以及计算和操作数组的基本工具。SciPy基于Numpy，提供了大量的计算和操作数组的函数，这些函数对于不同类型的科学和工程计算非常有用。</p>
<p>熟悉SciPy的最好方法就是阅读<a href="http://docs.scipy.org/doc/scipy/reference/index.html">文档</a>。我们会强调对于本课程有用的部分。</p>
<h3 id="tu-xiang-cao-zuo">图像操作</h3>
<p>SciPy提供了一些操作图像的基本函数。比如，它提供了将图像从硬盘读入到数组的函数，也提供了将数组中数据写入的硬盘成为图像的函数。下面是一个简单的例子：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">from scipy.misc import imread, imsave, imresize

# Read an JPEG image into a numpy array
img = imread(&#x27;assets&#x2F;cat.jpg&#x27;)
print(img.dtype, img.shape)  # Prints &quot;uint8 (400, 248, 3)&quot;

# We can tint the image by scaling each of the color channels
# by a different scalar constant. The image has shape (400, 248, 3);
# we multiply it by the array [1, 0.95, 0.9] of shape (3,);
# numpy broadcasting means that this leaves the red channel unchanged,
# and multiplies the green and blue channels by 0.95 and 0.9
# respectively.
img_tinted = img * [1, 0.95, 0.9]

# Resize the tinted image to be 300 by 300 pixels.
img_tinted = imresize(img_tinted, (300, 300))

# Write the tinted image back to disk
imsave(&#x27;assets&#x2F;cat_tinted.jpg&#x27;, img_tinted)
</code></pre>
<figure>
<img width="35%" src="./cat.jpg" />
<img width="35%" src="./cat_tinted.jpg" />
<br>
<p style="font-size:14px;">_左边是原始图片，右边是变色和变形的图片_</p>
</figure>
<h3 id="matlabwen-jian">MATLAB文件</h3>
<p>函数<code>scipy.io.loadmat</code>和<code>scipy.io.savemat</code>能够让你读和写MATLAB文件。具体请查看<a href="http://docs.scipy.org/doc/scipy/reference/io.html">文档</a>。</p>
<h3 id="dian-zhi-jian-de-ju-chi">点之间的距离</h3>
<p>SciPy定义了一些有用的函数，可以计算集合中点之间的距离。</p>
<p>函数<code>scipy.spatial.distance.pdist</code>能够计算集合中所有两点之间的距离：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np
from scipy.spatial.distance import pdist, squareform

# Create the following array where each row is a point in 2D space:
# [[0 1]
#  [1 0]
#  [2 0]]
x = np.array([[0, 1], [1, 0], [2, 0]])
print(x)

# Compute the Euclidean distance between all rows of x.
# d[i, j] is the Euclidean distance between x[i, :] and x[j, :],
# and d is the following array:
# [[ 0.          1.41421356  2.23606798]
#  [ 1.41421356  0.          1.        ]
#  [ 2.23606798  1.          0.        ]]
d = squareform(pdist(x, &#x27;euclidean&#x27;))
print(d)
</code></pre>
<p>具体细节请阅读<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html">文档</a>。</p>
<p>函数<code>scipy.spatial.distance.cdist</code>可以计算不同集合中点的距离，具体请查看<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html">文档</a>。</p>
<h2 id="matplotlib">Matplotlib</h2>
<p>Matplotlib是一个作图库。这里简要介绍'matplotlib.pyplot'模块，功能和MATLAB的作图功能类似。</p>
<h3 id="plotting">Plotting</h3>
<p>matplotlib库中最重要的函数是<code>Plot</code>。该函数允许你做出2D图形，如下：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np
import matplotlib.pyplot as plt

# Compute the x and y coordinates for points on a sine curve
x = np.arange(0, 3 * np.pi, 0.1)
y = np.sin(x)

# Plot the points using matplotlib
plt.plot(x, y)
plt.show()  # You must call plt.show() to make graphics appear.
</code></pre>
<figure>
<img src="./sine.png">
</figure>
<p>只需要少量工作，就可以一次画不同的线，加上标签，坐标轴标志等。</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np
import matplotlib.pyplot as plt

# Compute the x and y coordinates for points on sine and cosine curves
x = np.arange(0, 3 * np.pi, 0.1)
y_sin = np.sin(x)
y_cos = np.cos(x)

# Plot the points using matplotlib
plt.plot(x, y_sin)
plt.plot(x, y_cos)
plt.xlabel(&#x27;x axis label&#x27;)
plt.ylabel(&#x27;y axis label&#x27;)
plt.title(&#x27;Sine and Cosine&#x27;)
plt.legend([&#x27;Sine&#x27;, &#x27;Cosine&#x27;])
plt.show()
</code></pre>
<figure>
<img src="./sine_cosine.png">
</figure>
<h3 id="subplots">Subplots</h3>
<p>可以使用<code>subplot</code>函数来在一幅图中画不同的东西：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np
import matplotlib.pyplot as plt

# Compute the x and y coordinates for points on sine and cosine curves
x = np.arange(0, 3 * np.pi, 0.1)
y_sin = np.sin(x)
y_cos = np.cos(x)

# Set up a subplot grid that has height 2 and width 1,
# and set the first such subplot as active.
plt.subplot(2, 1, 1)

# Make the first plot
plt.plot(x, y_sin)
plt.title(&#x27;Sine&#x27;)

# Set the second subplot as active, and make the second plot.
plt.subplot(2, 1, 2)
plt.plot(x, y_cos)
plt.title(&#x27;Cosine&#x27;)

# Show the figure.
plt.show()
</code></pre>
<figure>
<img src="./sine_cosine_subplot.png">
</figure>
<p>关于<code>subplot</code>的更多细节，可以阅读<a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot">文档</a>。</p>
<h3 id="images">Images</h3>
<p>你可以使用<code>imshow</code>函数来显示图像，如下所示：</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">import numpy as np
from scipy.misc import imread, imresize
import matplotlib.pyplot as plt

img = imread(&#x27;assets&#x2F;cat.jpg&#x27;)
img_tinted = img * [1, 0.95, 0.9]

# Show the original image
plt.subplot(1, 2, 1)
plt.imshow(img)

# Show the tinted image
plt.subplot(1, 2, 2)

# A slight gotcha with imshow is that it might give strange results
# if presented with data that is not uint8. To work around this, we
# explicitly cast the image to uint8 before displaying it.
plt.imshow(np.uint8(img_tinted))
plt.show()
</code></pre>
<figure>
<img src="./cat_tinted_imshow.png">
</figure>

  </main>
  <p>
        Categories:
          <a href="/categories/su-cha-shou-ce/">#速查手册</a>
        Tags:
          <a href="/tags/handbook/">#handbook</a>
  </p>
  <hr>
  <section>
      <h2 id="comments" class="">Comments</h2>

      
          
      
      
    
    
    

    
        
        
    

    <p class="comment-note">
        你有问题需要解决，想要分享反馈，或者讨论更多的想法吗？请随时在这里留下评论！ 这个讨论将与 <a href="https://github.com/freeopen/freeopen.github.io/discussions/categories/post-comments?discussions_q=%22Python%20Numpy%20%E6%95%99%E7%A8%8B%22%20in%3Atitle"><em>discussion on GitHub</em></a> 直接连接，所以你也可以直接在那边发表评论

    </p>

    <div class="giscus"></div>

    <script src="https://giscus.app/client.js"
        data-repo="freeopen/freeopen.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnkxNjg3MTUxNzE="
        data-category="Post Comments"
        data-category-id="DIC_kwDOCg5jo84CpXQC"
    
        data-mapping="specific"
    
        data-term="Python Numpy 教程"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
    </script>

    <p class="comment-directly-on-github">
        Instead of authenticating the <a href="https://giscus.app">giscus</a> application, you can also comment directly <a href="https://github.com/freeopen/freeopen.github.io/discussions/categories/post-comments?discussions_q=%22Python%20Numpy%20%E6%95%99%E7%A8%8B%22%20in%3Atitle"><em>on GitHub</em></a>.
    </p>


  </section>

  </div><footer class="footer">
    <hr>
    <small>
        &copy; <time id="dynamic-year" datetime="2017">2017</time>. All rights reserved.
    </small>
</footer>
<script>
    const currentYear = new Date().getFullYear();

    const timeElement = document.getElementById('dynamic-year');
    timeElement.textContent = `2017 - ${currentYear}`;
    timeElement.setAttribute('datetime', `2017/${currentYear}`);
</script>
</body>
</html>
